From a48245b341f822917414e5344dab977888563e30 Mon Sep 17 00:00:00 2001
From: donaldduck70 <spigot@homemp3.dyndns.org>
Date: Tue, 9 Jan 2018 00:48:23 +0100
Subject: [PATCH] SPIGOT-3747: added CraftPlayerChunk[Map] implementations and
 required nms-patches


diff --git a/nms-patches/ChatBaseComponent.patch b/nms-patches/ChatBaseComponent.patch
index bd82c4a1..255e41df 100644
--- a/nms-patches/ChatBaseComponent.patch
+++ b/nms-patches/ChatBaseComponent.patch
@@ -1,5 +1,14 @@
 --- a/net/minecraft/server/ChatBaseComponent.java
 +++ b/net/minecraft/server/ChatBaseComponent.java
+@@ -57,7 +57,7 @@
+     }
+ 
+     public Iterator<IChatBaseComponent> iterator() {
+-        return Iterators.concat(Iterators.forArray(new ChatBaseComponent[] { this}), a((Iterable) this.a));
++        return Iterators.concat(Iterators.forArray(new ChatBaseComponent[] { this}), a((Iterable<IChatBaseComponent>) this.a));
+     }
+ 
+     public final String toPlainText() {
 @@ -112,7 +112,7 @@
      }
  
diff --git a/nms-patches/PlayerChunk.patch b/nms-patches/PlayerChunk.patch
index 2dc88641..b92117bc 100644
--- a/nms-patches/PlayerChunk.patch
+++ b/nms-patches/PlayerChunk.patch
@@ -1,6 +1,6 @@
 --- a/net/minecraft/server/PlayerChunk.java
 +++ b/net/minecraft/server/PlayerChunk.java
-@@ -8,32 +8,48 @@
+@@ -8,32 +8,55 @@
  import javax.annotation.Nullable;
  import org.apache.logging.log4j.LogManager;
  import org.apache.logging.log4j.Logger;
@@ -32,6 +32,13 @@
 +            PlayerChunk.this.chunk = PlayerChunk.this.playerChunkMap.getWorld().getChunkProviderServer().getOrLoadChunkAt(location.x, location.z);
 +        }
 +    };
++
++    /**
++     * Keeps the player chunk in the PlayerChunkMap and hence ticking even if it contains no players anymore
++     * 
++     * @see #setSticky(boolean)
++     */
++    private boolean stickyInPlayerChunkMap;
 +    // CraftBukkit end
 +
      public PlayerChunk(PlayerChunkMap playerchunkmap, int i, int j) {
@@ -53,7 +60,7 @@
          if (this.c.contains(entityplayer)) {
              PlayerChunk.a.debug("Failed to add player. {} already is in chunk {}, {}", entityplayer, Integer.valueOf(this.location.x), Integer.valueOf(this.location.z));
          } else {
-@@ -42,15 +58,32 @@
+@@ -42,36 +65,85 @@
              }
  
              this.c.add(entityplayer);
@@ -75,7 +82,7 @@
 +            if (!this.done) {
 +                this.c.remove(entityplayer);
 +
-+                if (this.c.isEmpty()) {
++                if (this.c.isEmpty() && !isSticky()) { // Spigot: keep if forced, to cause chunk ticks
 +                    ChunkIOExecutor.dropQueuedChunkLoad(this.playerChunkMap.getWorld(), this.location.x, this.location.z, this.loadedRunnable);
 +                    this.playerChunkMap.b(this);
 +                }
@@ -86,7 +93,42 @@
              if (this.done) {
                  entityplayer.playerConnection.sendPacket(new PacketPlayOutUnloadChunk(this.location.x, this.location.z));
              }
-@@ -67,11 +100,18 @@
+ 
+             this.c.remove(entityplayer);
+-            if (this.c.isEmpty()) {
++            if (this.c.isEmpty() && !isSticky()) { // CraftBukkit: keep if forced, to cause chunk ticks
+                 this.playerChunkMap.b(this);
+             }
+ 
+         }
+     }
+ 
++    
++    // CraftBukkit start - release this PlayerChunk if already empty
++    /**
++     * @return {@code true} whether this player chunk will remain loaded even if it has no player associated anymore
++     */
++    public boolean isSticky() {
++        return stickyInPlayerChunkMap;
++    }
++    
++    /**
++     * Forces this player chunk to remain in its {@link #playerChunkMap} even if it contains
++     * no player entities anymore in case {@code sticky} is {@code true}; if {@code sticky} is
++     * {@code false} and no player is seeing this chunk, the chunk is removed from the
++     * {@link org.bukkit.PlayerChunkMap}.
++     */
++    public void setSticky(boolean sticky) {
++        stickyInPlayerChunkMap = sticky;
++        if (!sticky) {
++            if (this.c.isEmpty()) {
++                this.playerChunkMap.b(this);
++            }
++        }
++    }
++    // CraftBukkit end
++
+     public boolean a(boolean flag) {
          if (this.chunk != null) {
              return true;
          } else {
diff --git a/nms-patches/PlayerChunkMap.patch b/nms-patches/PlayerChunkMap.patch
index 37c4c474..cc360e67 100644
--- a/nms-patches/PlayerChunkMap.patch
+++ b/nms-patches/PlayerChunkMap.patch
@@ -19,6 +19,15 @@
  
      public PlayerChunkMap(WorldServer worldserver) {
          this.world = worldserver;
+@@ -78,7 +83,7 @@
+                             return chunk;
+                         }
+ 
+-                        if (!playerchunk.a(128.0D, PlayerChunkMap.a)) {
++                        if (!playerchunk.isSticky() && !playerchunk.a(128.0D, PlayerChunkMap.a)) { // Spigot: always return force-ticking chunks
+                             continue;
+                         }
+ 
 @@ -169,7 +174,11 @@
                              break;
                          }
@@ -31,7 +40,7 @@
              }
          }
  
-@@ -231,6 +240,16 @@
+@@ -231,6 +240,28 @@
          return playerchunk;
      }
  
@@ -43,12 +52,24 @@
 +        }
 +        return false;
 +    }
++
++    /**
++     * Force-loads the chunk at the chunk coordinates specified and marks
++     * the resulting {@link PlayerChunk} with {@link PlayerChunk#setSticky(boolean)}.
++     * Useful for plugins that would like to force chunk ticks even in case they are not
++     * loaded yet, e.g., during plugin start-up.
++     */
++    public PlayerChunk keepPlayerChunkTicking(int x, int z) {
++        final PlayerChunk result = c(x, z);
++        result.setSticky(true);
++        return result;
++    }
 +    // CraftBukkit end
 +
      public void flagDirty(BlockPosition blockposition) {
          int i = blockposition.getX() >> 4;
          int j = blockposition.getZ() >> 4;
-@@ -249,12 +268,22 @@
+@@ -249,12 +280,22 @@
          entityplayer.d = entityplayer.locX;
          entityplayer.e = entityplayer.locZ;
  
@@ -72,7 +93,7 @@
          this.managedPlayers.add(entityplayer);
          this.e();
      }
-@@ -298,11 +327,14 @@
+@@ -298,11 +339,14 @@
              int j1 = i - k;
              int k1 = j - l;
  
@@ -88,7 +109,7 @@
                          }
  
                          if (!this.a(l1 - j1, i2 - k1, i, j, i1)) {
-@@ -318,6 +350,13 @@
+@@ -318,6 +362,13 @@
                  entityplayer.d = entityplayer.locX;
                  entityplayer.e = entityplayer.locZ;
                  this.e();
@@ -102,7 +123,7 @@
              }
          }
      }
-@@ -402,4 +441,47 @@
+@@ -402,4 +453,47 @@
          }
  
      }
diff --git a/nms-patches/WorldServer.patch b/nms-patches/WorldServer.patch
index b5178ece..1d67d706 100644
--- a/nms-patches/WorldServer.patch
+++ b/nms-patches/WorldServer.patch
@@ -317,7 +317,15 @@
  
              return false;
          } else {
-@@ -283,7 +479,7 @@
+@@ -266,6 +462,7 @@
+                 chunk.n();
+                 this.methodProfiler.c("tickChunk");
+                 chunk.b(false);
++                if ( !manager.getChunk(chunk.locX, chunk.locZ).isSticky()) continue; // CraftBukkit
+                 this.methodProfiler.c("thunder");
+                 int l;
+                 BlockPosition blockposition;
+@@ -283,7 +480,7 @@
                              entityhorseskeleton.p(true);
                              entityhorseskeleton.setAgeRaw(0);
                              entityhorseskeleton.setPosition((double) blockposition.getX(), (double) blockposition.getY(), (double) blockposition.getZ());
@@ -326,7 +334,7 @@
                              this.strikeLightning(new EntityLightning(this, (double) blockposition.getX(), (double) blockposition.getY(), (double) blockposition.getZ(), true));
                          } else {
                              this.strikeLightning(new EntityLightning(this, (double) blockposition.getX(), (double) blockposition.getY(), (double) blockposition.getZ(), false));
-@@ -299,11 +495,11 @@
+@@ -299,11 +496,11 @@
                      BlockPosition blockposition1 = blockposition.down();
  
                      if (this.v(blockposition1)) {
@@ -340,7 +348,7 @@
                      }
  
                      if (flag && this.getBiome(blockposition1).d()) {
-@@ -378,7 +574,7 @@
+@@ -378,7 +575,7 @@
      public boolean b(BlockPosition blockposition, Block block) {
          NextTickListEntry nextticklistentry = new NextTickListEntry(blockposition, block);
  
@@ -349,7 +357,7 @@
      }
  
      public void a(BlockPosition blockposition, Block block, int i) {
-@@ -412,8 +608,8 @@
+@@ -412,8 +609,8 @@
                  nextticklistentry.a(j);
              }
  
@@ -360,7 +368,7 @@
                  this.nextTickList.add(nextticklistentry);
              }
          }
-@@ -430,15 +626,15 @@
+@@ -430,15 +627,15 @@
              nextticklistentry.a((long) i + this.worldData.getTime());
          }
  
@@ -379,7 +387,7 @@
              if (this.emptyTime++ >= 300) {
                  return;
              }
-@@ -508,11 +704,17 @@
+@@ -508,11 +705,17 @@
          } else {
              int i = this.nextTickList.size();
  
@@ -399,7 +407,7 @@
                  }
  
                  this.methodProfiler.a("cleaning");
-@@ -525,8 +727,9 @@
+@@ -525,8 +728,9 @@
                          break;
                      }
  
@@ -410,7 +418,7 @@
                      this.W.add(nextticklistentry);
                  }
  
-@@ -596,7 +799,7 @@
+@@ -596,7 +800,7 @@
                  if (blockposition.getX() >= structureboundingbox.a && blockposition.getX() < structureboundingbox.d && blockposition.getZ() >= structureboundingbox.c && blockposition.getZ() < structureboundingbox.f) {
                      if (flag) {
                          if (i == 0) {
@@ -419,7 +427,7 @@
                          }
  
                          iterator.remove();
-@@ -614,6 +817,7 @@
+@@ -614,6 +818,7 @@
          return arraylist;
      }
  
@@ -427,7 +435,7 @@
      public void entityJoinedWorld(Entity entity, boolean flag) {
          if (!this.getSpawnAnimals() && (entity instanceof EntityAnimal || entity instanceof EntityWaterAnimal)) {
              entity.die();
-@@ -625,6 +829,7 @@
+@@ -625,6 +830,7 @@
  
          super.entityJoinedWorld(entity, flag);
      }
@@ -435,7 +443,7 @@
  
      private boolean getSpawnNPCs() {
          return this.server.getSpawnNPCs();
-@@ -637,7 +842,54 @@
+@@ -637,7 +843,54 @@
      protected IChunkProvider n() {
          IChunkLoader ichunkloader = this.dataManager.createChunkLoader(this.worldProvider);
  
@@ -491,7 +499,7 @@
      }
  
      public boolean a(EntityHuman entityhuman, BlockPosition blockposition) {
-@@ -699,6 +951,23 @@
+@@ -699,6 +952,23 @@
              int j = this.worldProvider.getSeaLevel();
              int k = 8;
  
@@ -515,7 +523,7 @@
              if (blockposition != null) {
                  i = blockposition.getX();
                  k = blockposition.getZ();
-@@ -708,7 +977,7 @@
+@@ -708,7 +978,7 @@
  
              int l = 0;
  
@@ -524,7 +532,7 @@
                  i += random.nextInt(64) - random.nextInt(64);
                  k += random.nextInt(64) - random.nextInt(64);
                  ++l;
-@@ -750,6 +1019,7 @@
+@@ -750,6 +1020,7 @@
          ChunkProviderServer chunkproviderserver = this.getChunkProviderServer();
  
          if (chunkproviderserver.e()) {
@@ -532,7 +540,7 @@
              if (iprogressupdate != null) {
                  iprogressupdate.a("Saving level");
              }
-@@ -760,7 +1030,8 @@
+@@ -760,7 +1031,8 @@
              }
  
              chunkproviderserver.a(flag);
@@ -542,7 +550,7 @@
              Iterator iterator = arraylist.iterator();
  
              while (iterator.hasNext()) {
-@@ -795,6 +1066,12 @@
+@@ -795,6 +1067,12 @@
              }
          }
  
@@ -555,7 +563,7 @@
          this.worldData.a(this.getWorldBorder().getSize());
          this.worldData.d(this.getWorldBorder().getCenterX());
          this.worldData.c(this.getWorldBorder().getCenterZ());
-@@ -808,9 +1085,13 @@
+@@ -808,9 +1086,13 @@
          this.worldMaps.a();
      }
  
@@ -571,7 +579,7 @@
  
      public void a(Collection<Entity> collection) {
          ArrayList arraylist = Lists.newArrayList(collection);
-@@ -829,7 +1110,7 @@
+@@ -829,7 +1111,7 @@
  
      private boolean j(Entity entity) {
          if (entity.dead) {
@@ -580,7 +588,7 @@
              return false;
          } else {
              UUID uuid = entity.getUniqueID();
-@@ -841,7 +1122,7 @@
+@@ -841,7 +1123,7 @@
                      this.f.remove(entity1);
                  } else {
                      if (!(entity instanceof EntityHuman)) {
@@ -589,7 +597,7 @@
                          return false;
                      }
  
-@@ -894,8 +1175,16 @@
+@@ -894,8 +1176,16 @@
      }
  
      public boolean strikeLightning(Entity entity) {
@@ -607,7 +615,7 @@
              return true;
          } else {
              return false;
-@@ -911,10 +1200,20 @@
+@@ -911,10 +1201,20 @@
      }
  
      public Explosion createExplosion(@Nullable Entity entity, double d0, double d1, double d2, float f, boolean flag, boolean flag1) {
@@ -628,7 +636,7 @@
          if (!flag1) {
              explosion.clearBlocks();
          }
-@@ -960,7 +1259,8 @@
+@@ -960,7 +1260,8 @@
                  BlockActionData blockactiondata = (BlockActionData) iterator.next();
  
                  if (this.a(blockactiondata)) {
@@ -638,7 +646,7 @@
                  }
              }
  
-@@ -983,6 +1283,7 @@
+@@ -983,6 +1284,7 @@
          boolean flag = this.isRaining();
  
          super.t();
@@ -646,7 +654,7 @@
          if (this.n != this.o) {
              this.server.getPlayerList().a((Packet) (new PacketPlayOutGameStateChange(7, this.o)), this.worldProvider.getDimensionManager().getDimensionID());
          }
-@@ -1001,6 +1302,21 @@
+@@ -1001,6 +1303,21 @@
              this.server.getPlayerList().sendAll(new PacketPlayOutGameStateChange(7, this.o));
              this.server.getPlayerList().sendAll(new PacketPlayOutGameStateChange(8, this.q));
          }
@@ -668,7 +676,7 @@
  
      }
  
-@@ -1030,10 +1346,20 @@
+@@ -1030,10 +1347,20 @@
      }
  
      public void a(EnumParticle enumparticle, boolean flag, double d0, double d1, double d2, int i, double d3, double d4, double d5, double d6, int... aint) {
diff --git a/src/main/java/org/bukkit/craftbukkit/AbstractWrapper.java b/src/main/java/org/bukkit/craftbukkit/AbstractWrapper.java
new file mode 100644
index 00000000..7bd82d10
--- /dev/null
+++ b/src/main/java/org/bukkit/craftbukkit/AbstractWrapper.java
@@ -0,0 +1,45 @@
+package org.bukkit.craftbukkit;
+
+import java.lang.ref.WeakReference;
+
+import net.minecraft.server.WorldServer;
+
+/**
+ * Wraps a Minecraft object of type {@code T}, keeping a weak reference to it,
+ * and a strong reference to the {@link WorldServer}. Access to the referent
+ * happens in the {@link #getHandle} method where the object needs to be
+ * re-resolved starting from the {@link WorldServer} if the weak reference was
+ * had its referent collected in the meantime.
+ * <p>
+ * 
+ * Implementing subclasses have to use their constructor to store context data
+ * such as, e.g., the {@link WorldServer} that provides the context to
+ * {@link #retrieve} the {@code t} object equivalent again at a later point
+ * after the {@code t} object itself was garbage collected.
+ * <p>
+ * 
+ * @param <T>
+ */
+public abstract class AbstractWrapper<T> {
+	private WeakReference<T> handle;
+	
+	protected AbstractWrapper(T t) {
+		handle = new WeakReference<>(t);
+	}
+
+	/**
+	 * Retrieves an object equivalent to the original {@code T} object passed to the constructor, based
+	 * on the context data remembered during the call to {@link #rememberQueryData(Object)} that the
+	 * constructor performs.
+	 */
+	protected abstract T retrieve();
+	
+	protected T getHandle() {
+		T result = handle.get();
+		if (result == null) {
+			result = retrieve();
+			handle = new WeakReference<>(result);
+		}
+		return result;
+	}
+}
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftPlayerChunk.java b/src/main/java/org/bukkit/craftbukkit/CraftPlayerChunk.java
new file mode 100755
index 00000000..f263c25d
--- /dev/null
+++ b/src/main/java/org/bukkit/craftbukkit/CraftPlayerChunk.java
@@ -0,0 +1,47 @@
+package org.bukkit.craftbukkit;
+
+import org.bukkit.Chunk;
+import org.bukkit.PlayerChunk;
+
+import net.minecraft.server.PlayerChunkMap;
+import net.minecraft.server.WorldServer;
+
+public class CraftPlayerChunk extends AbstractWrapper<net.minecraft.server.PlayerChunk> implements PlayerChunk {
+    private final WorldServer world;
+    private final int x;
+    private final int z;
+
+    public CraftPlayerChunk(net.minecraft.server.PlayerChunk playerChunk) {
+        super(playerChunk);
+        world = playerChunk.chunk.world.worldData.world;
+        this.x = playerChunk.chunk.locX;
+        this.z = playerChunk.chunk.locZ;
+    }
+
+    @Override
+    protected net.minecraft.server.PlayerChunk retrieve() {
+        return world.getPlayerChunkMap().getChunk(x, z);
+    }
+
+    @Override
+    public Chunk getChunk() {
+        return new CraftChunk(getHandle().chunk);
+    }
+
+    /**
+     * @return {@code true} whether this player chunk will remain loaded even if it has no player associated anymore
+     */
+    @Override
+    public boolean isSticky() {
+        return getHandle().isSticky();
+    }
+
+    /**
+     * Forces this player chunk to remain in its {@link #playerChunkMap} even if it contains no player entities anymore,
+     * or releases the chunk if {@code sticky} is {@code false}.
+     */
+    @Override
+    public void setSticky(boolean sticky) {
+        getHandle().setSticky(sticky);
+    }
+}
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftPlayerChunkMap.java b/src/main/java/org/bukkit/craftbukkit/CraftPlayerChunkMap.java
new file mode 100644
index 00000000..4c7730c4
--- /dev/null
+++ b/src/main/java/org/bukkit/craftbukkit/CraftPlayerChunkMap.java
@@ -0,0 +1,31 @@
+package org.bukkit.craftbukkit;
+
+import org.bukkit.PlayerChunk;
+import org.bukkit.PlayerChunkMap;
+
+import net.minecraft.server.WorldServer;
+
+public class CraftPlayerChunkMap extends AbstractWrapper<net.minecraft.server.PlayerChunkMap>
+        implements PlayerChunkMap {
+    private final WorldServer world;
+
+    public CraftPlayerChunkMap(net.minecraft.server.PlayerChunkMap playerChunkMap) {
+        super(playerChunkMap);
+        world = playerChunkMap.getWorld();
+    }
+
+    @Override
+    public PlayerChunk getPlayerChunk(int x, int z) {
+        return new CraftPlayerChunk(getHandle().getChunk(x, z));
+    }
+
+    @Override
+    public void keepPlayerChunkTicking(int x, int z) {
+        getHandle().keepPlayerChunkTicking(x, z);
+    }
+
+    @Override
+    protected net.minecraft.server.PlayerChunkMap retrieve() {
+        return world.getPlayerChunkMap();
+    }
+}
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
index 8f6653f7..236bd733 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
@@ -1,19 +1,16 @@
 package org.bukkit.craftbukkit;
 
-import com.google.common.base.Preconditions;
 import java.io.File;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.HashSet;
-import java.util.List;
 import java.util.Iterator;
+import java.util.List;
 import java.util.Random;
 import java.util.Set;
 import java.util.UUID;
 
-import net.minecraft.server.*;
-
 import org.apache.commons.lang.Validate;
 import org.bukkit.BlockChangeDelegate;
 import org.bukkit.Bukkit;
@@ -23,6 +20,7 @@ import org.bukkit.Difficulty;
 import org.bukkit.Effect;
 import org.bukkit.Location;
 import org.bukkit.Particle;
+import org.bukkit.PlayerChunkMap;
 import org.bukkit.Sound;
 import org.bukkit.TreeType;
 import org.bukkit.World;
@@ -33,14 +31,107 @@ import org.bukkit.block.BlockFace;
 import org.bukkit.block.BlockState;
 import org.bukkit.craftbukkit.block.CraftBlock;
 import org.bukkit.craftbukkit.block.CraftBlockState;
-import org.bukkit.craftbukkit.entity.*;
+import org.bukkit.craftbukkit.entity.CraftItem;
+import org.bukkit.craftbukkit.entity.CraftLightningStrike;
+import org.bukkit.craftbukkit.entity.CraftPlayer;
 import org.bukkit.craftbukkit.inventory.CraftItemStack;
 import org.bukkit.craftbukkit.metadata.BlockMetadataStore;
 import org.bukkit.craftbukkit.potion.CraftPotionUtil;
 import org.bukkit.craftbukkit.util.CraftMagicNumbers;
-import org.bukkit.craftbukkit.util.LongHash;
-import org.bukkit.entity.*;
+import org.bukkit.entity.AbstractHorse;
+import org.bukkit.entity.Ambient;
+import org.bukkit.entity.AreaEffectCloud;
+import org.bukkit.entity.ArmorStand;
+import org.bukkit.entity.Arrow;
+import org.bukkit.entity.Bat;
+import org.bukkit.entity.Blaze;
+import org.bukkit.entity.Boat;
+import org.bukkit.entity.CaveSpider;
+import org.bukkit.entity.ChestedHorse;
+import org.bukkit.entity.Chicken;
+import org.bukkit.entity.ComplexLivingEntity;
+import org.bukkit.entity.Cow;
+import org.bukkit.entity.Creeper;
+import org.bukkit.entity.Donkey;
+import org.bukkit.entity.DragonFireball;
+import org.bukkit.entity.Egg;
+import org.bukkit.entity.ElderGuardian;
+import org.bukkit.entity.EnderCrystal;
+import org.bukkit.entity.EnderDragon;
+import org.bukkit.entity.EnderPearl;
+import org.bukkit.entity.EnderSignal;
+import org.bukkit.entity.Enderman;
+import org.bukkit.entity.Endermite;
 import org.bukkit.entity.Entity;
+import org.bukkit.entity.EntityType;
+import org.bukkit.entity.Evoker;
+import org.bukkit.entity.EvokerFangs;
+import org.bukkit.entity.ExperienceOrb;
+import org.bukkit.entity.FallingBlock;
+import org.bukkit.entity.Fireball;
+import org.bukkit.entity.Firework;
+import org.bukkit.entity.Ghast;
+import org.bukkit.entity.Giant;
+import org.bukkit.entity.Golem;
+import org.bukkit.entity.Guardian;
+import org.bukkit.entity.Hanging;
+import org.bukkit.entity.HumanEntity;
+import org.bukkit.entity.Husk;
+import org.bukkit.entity.Illager;
+import org.bukkit.entity.Illusioner;
+import org.bukkit.entity.IronGolem;
+import org.bukkit.entity.ItemFrame;
+import org.bukkit.entity.LeashHitch;
+import org.bukkit.entity.LightningStrike;
+import org.bukkit.entity.LingeringPotion;
+import org.bukkit.entity.LivingEntity;
+import org.bukkit.entity.Llama;
+import org.bukkit.entity.LlamaSpit;
+import org.bukkit.entity.MagmaCube;
+import org.bukkit.entity.Minecart;
+import org.bukkit.entity.Mule;
+import org.bukkit.entity.MushroomCow;
+import org.bukkit.entity.Ocelot;
+import org.bukkit.entity.Painting;
+import org.bukkit.entity.Parrot;
+import org.bukkit.entity.Pig;
+import org.bukkit.entity.PigZombie;
+import org.bukkit.entity.Player;
+import org.bukkit.entity.PolarBear;
+import org.bukkit.entity.Projectile;
+import org.bukkit.entity.Rabbit;
+import org.bukkit.entity.Sheep;
+import org.bukkit.entity.Shulker;
+import org.bukkit.entity.ShulkerBullet;
+import org.bukkit.entity.Silverfish;
+import org.bukkit.entity.Skeleton;
+import org.bukkit.entity.SkeletonHorse;
+import org.bukkit.entity.Slime;
+import org.bukkit.entity.SmallFireball;
+import org.bukkit.entity.Snowball;
+import org.bukkit.entity.Snowman;
+import org.bukkit.entity.SpectralArrow;
+import org.bukkit.entity.Spellcaster;
+import org.bukkit.entity.Spider;
+import org.bukkit.entity.Squid;
+import org.bukkit.entity.Stray;
+import org.bukkit.entity.TNTPrimed;
+import org.bukkit.entity.Tameable;
+import org.bukkit.entity.ThrownExpBottle;
+import org.bukkit.entity.ThrownPotion;
+import org.bukkit.entity.TippedArrow;
+import org.bukkit.entity.Vex;
+import org.bukkit.entity.Villager;
+import org.bukkit.entity.Vindicator;
+import org.bukkit.entity.Weather;
+import org.bukkit.entity.Witch;
+import org.bukkit.entity.Wither;
+import org.bukkit.entity.WitherSkeleton;
+import org.bukkit.entity.WitherSkull;
+import org.bukkit.entity.Wolf;
+import org.bukkit.entity.Zombie;
+import org.bukkit.entity.ZombieHorse;
+import org.bukkit.entity.ZombieVillager;
 import org.bukkit.entity.minecart.CommandMinecart;
 import org.bukkit.entity.minecart.ExplosiveMinecart;
 import org.bukkit.entity.minecart.HopperMinecart;
@@ -61,6 +152,10 @@ import org.bukkit.potion.PotionType;
 import org.bukkit.util.Consumer;
 import org.bukkit.util.Vector;
 
+import com.google.common.base.Preconditions;
+
+import net.minecraft.server.*;
+
 public class CraftWorld implements World {
     public static final int CUSTOM_DIMENSION_OFFSET = 10;
 
@@ -138,6 +233,11 @@ public class CraftWorld implements World {
         return this.world.getChunkProviderServer().getChunkAt(x, z).bukkitChunk;
     }
 
+    @Override
+    public PlayerChunkMap getPlayerChunkMap() {
+        return new CraftPlayerChunkMap(this.world.getPlayerChunkMap());
+    }
+
     public Chunk getChunkAt(Block block) {
         return getChunkAt(block.getX() >> 4, block.getZ() >> 4);
     }
-- 
2.15.1

